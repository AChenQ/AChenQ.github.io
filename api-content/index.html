{"posts":[{"title":"nodejs和node版本不一致问题","content":"安装包遇见了这样的问题 ERROR: npm v9.5.1 is known not to run on Node.js v12.22.9. 但是调用版本命令发现node的版本不一致 $ npm -v 9.5.1 $ node -v v18.16.0 $ nodejs --versions v12.22.9 发现机器上有两个nodejs，包读取的node为另一个 排除发现是node是通过 n工具安装的，需要把另一个系统安装的去除 sudo apt-get remove nodejs ","link":"https://achenq.github.io/post/nodejs-he-node-ban-ben-bu-yi-zhi-wen-ti/"},{"title":"python selenium 全屏截图","content":"主要思路: 滚动条下滑，屏幕截图之后，通过PIL库拼接 主要问题: selenium获取的页面高度存在误差，会导致拼接出来的图片存在重叠或者覆盖 实现逻辑: 获取总页面高度 body_height 将滚动条下滑到最底端, 获取此时滚动条顶端与页面顶端的距离 scroll_to_top 获取滚动条的长度 scroll_length, 也是下滑截图时间隔 将滚动条挪到最顶端，开始截图 移动滚动条，每次下滑scroll_length, 并截图，拼接 直到当前滚动条顶端与页面顶端的距离, 小于滚动条长度时，代表下一张图到达了网页的底端 最后一张图片会与上一张图片有重合的内容，覆盖间隔为当前滚动条顶端与scroll_to_top的差额 代码实现: from PIL import Image from selenium import webdriver def join_images(self, png1, png2, size=0): &quot;&quot;&quot; 图片拼接 :param png1: 图片1 :param png2: 图片2 :param size: 两个图片重叠的距离 :return: &quot;&quot;&quot; img1, img2 = Image.open(BytesIO(png1)), Image.open(BytesIO(png2)) # 打开图片对象 size1, size2 = img1.size, img2.size # 获取两张图片的大小 joint = Image.new('RGB', (size1[0], size1[1] + size2[1] - size)) # 创建一个空白图片 # 设置两张图片要放置的初始位置 loc1, loc2 = (0, 0), (0, size1[1] - size) # 分别放置图片 joint.paste(img1, loc1) joint.paste(img2, loc2) # 图片转bytes返回 img_bytes_arr = BytesIO() # 二进制容器 joint.save(img_bytes_arr, format=&quot;PNG&quot;) return img_bytes_arr.getvalue() driver = webdriver.Chrome(webdriver.ChromeOptions()) image_bytes = driver.get_screenshot_as_png() body_height = driver.execute_script(&quot;return document.documentElement.scrollHeight&quot;) driver.execute_script(&quot;window.scroll({top:document.body.clientHeight,left:0,behavior:'auto'});&quot;) # 滚动条滚动到最底端时，滚动条顶端距离页面顶端的距离 bottom_h = driver.execute_script(&quot;return document.documentElement.scrollTop&quot;) # 滚动条的changdu scroll_length = body_height - bottom_h current_h = 0 driver.execute_script(&quot;window.scroll({top:0,left:0,behavior:'auto'});&quot;) while current_h &lt; bottom_h: # 如果剩余的高度大于滚动条的高度，则下滑直接完整拼接 if bottom_h - current_h &gt; scroll_length: current_h += scroll_length join_size = 0 # 如果剩余的高度小于滚动条的高度，则接下来为最后一张图，需要处理拼接 else: join_size = bottom_h - current_h current_h += join_size # 1. 滚动到指定锚点 driver.execute_script(&quot;window.scroll({top:%d,left:0,behavior:'auto'});&quot;.format(current_h)) # 2. 截图 image_bytes_r = driver.get_screenshot_as_png() # 3. 拼接 image_bytes = self.join_images(image_bytes, image_bytes_r, join_size) # 截图保存本地 with open(f&quot;test.png&quot;, mode=&quot;wb&quot;) as f: f.write(image_bytes) ","link":"https://achenq.github.io/post/python-selenium-picture/"},{"title":"笔记本改家用服务器记录","content":"原来笔记本铰链坏了，也不怎么用了，最近有空准备刷成ubuntu放在家里当服务器用 改造步骤 刷ubuntu系统 配置ubuntu系统 使用cpolar配置内网穿透 运行服务 刷ubuntu系统 下载iso镜像 因为屏幕还能用，所以刷了一个带桌面的ubuntu系统 国内可以在清华大学开源软件镜像站下载，网址: https://mirrors.tuna.tsinghua.edu.cn/ 点击获取下载连接，我选择的20.04.5 (amd64, Desktop LiveDVD) 通过rufus制作启动盘 rufus下载地址： http://rufus.ie/zh 下载后选择u盘和iso镜像安装即可，注意制作前会清空u盘原有存储内容 配置ubuntu系统 配置ubuntu源 编辑 /etc/apt/sources.list, 最前列添加以下源 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 运行 sudo apt-get update sudo apt-get upgrade 配置系统不自动休眠 由于多数时候是远程控制，所以要保证系统不会自动休眠 sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target Created symlink /etc/systemd/system/sleep.target → /dev/null. Created symlink /etc/systemd/system/suspend.target → /dev/null. Created symlink /etc/systemd/system/hibernate.target → /dev/null. Created symlink /etc/systemd/system/hybrid-sleep.target → /dev/null. 配置梯子 使用v2ray进行配置 安装v2ray 参考 https://qiyuan-z.github.io/2020/02/23/Ubuntu%E9%85%8D%E7%BD%AEv2ray%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/#post-comment 配置cpolar内网穿透 家用网络通常是不存在公网ip的，所以需要通过工具来配置公网ip以便访问 注册cpolar账号, 获取token cpolar官网 安装cpolar curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 配置token cpolar authtoken xxxxxxx 添加并启动cpolar sudo systemctl enable cpolar sudo systemctl start cpolar 代理tcp 22端口(ssh 一般通过此端口) cpolar tcp 22 远程通过下列命令登录即可 注意免费版cpolar长时间不用，此连接会被关闭，重新运行后地址会发生变化 ssh user@xxx.tcp.cpolar.cn -p 24177 查看公网ip 打开 https://dashboard.cpolar.com/status [注]: 更多cpolar操作请查看 cpolar使用文档 ","link":"https://achenq.github.io/post/bi-ji-ben-gai-jia-yong-fu-wu-qi-ji-lu/"},{"title":"python 获取计算机资源，进程信息","content":" 进程管理 CPU管理 内存管理 磁盘管理 主要通过psutil进行操作 官网地址: https://psutil.readthedocs.io/en/latest/ 进程管理 for proc in psutil.process_iter([&quot;cmdline&quot;]): if process_name in &quot;&quot;.join(proc.cmdline()): Message.info(f&quot;检测{process_name}正在运行中&quot;) 获取平均使用率 CPU管理 cpu_usage = psutil.cpu_percent() 内存管理 memory_usage = psutil.virtual_memory().percent 磁盘管理 disk_usage = psutil.disk_usage(&quot;/&quot;).percent ","link":"https://achenq.github.io/post/python-huo-qu-ji-suan-ji-zi-yuan-jin-cheng-xin-xi/"},{"title":"shell常用命令","content":"通过进程名查找PID &amp;&amp; 通过PID查找进程名 ps -ef | grep 'name' name为模糊匹配，所有包括此name的都会打印出来 通过端口查看占用进程 通过netstat查看所有TCP端口占用情况 netstat -ntlp | grep 'port' ","link":"https://achenq.github.io/post/shell-chang-yong-ming-ling/"},{"title":"shell脚本编程","content":"脚本解释器 一般第一行指要用什么解释器来运行此脚本， 一般有bash, zsh, sh等 #!/bin/bash 可以用命令查看本系统现在支持哪些脚本解释器 cat /etc/shells 变量 通过$进行引用 NAME=&quot;Tom&quot; echo &quot;Hello, $NAME&quot; ps: 也可以把命令的输出结果，赋值给某个变量 LIST=$(ls) read-用户输入 通过read读取输入, -p是指显示提示信息PROMPT MESSAGE, 并将用户输入复制给后面的变量 更多选项可参考: read 使用 read -p &quot;PROMPT MESSAGE&quot; VARIABLE 示例 #!/bin/bash read -p &quot;Please Enter You Name: &quot; NAME echo &quot;Your Name Is: $NAME&quot; shell 还支持很多内置命令, 列举: shell 内置命令 if条件判断 可以通过if, elif, else关键字进行判断 if [ condition-is-true ] then command 1 elif [ condition-is-true ] then command 2 elif [ condition-is-true ] then command 3 else command 4 fi 条件是否成立[[]] 由于[[]]完全兼容test和[]，所以推荐使用[[]]即可 通常与if一起, 可以通过[[ expression ]]使用 注意后面的[[]]前后一定要有空格, 不能是[[expression]] #!/bin/bash read age if [[ $age -le 3 ]]; then echo &quot;婴儿&quot; elif [[ $age -ge 3 &amp;&amp; $age -le 8 ]]; then echo &quot;幼儿&quot; else echo &quot;成年&quot; fi 文件选项列表 选 项 作 用 -d filename 判断文件是否存在，并且是否为目录文件。 -e filename 判断文件是否存在。 -f filename 判断文件是否存在，井且是否为普通文件。 -p filename 判断文件是否存在，并且是否为管道文件。 -s filename 判断文件是否存在，并且是否为非空。 -r filename 判断文件是否存在，并且是否拥有读权限。 -w filename 判断文件是否存在，并且是否拥有写权限。 -x filename 判断文件是否存在，并且是否拥有执行权限。 filename1 -nt filename2 判断 filename1 的修改时间是否比 filename2 的新。 filename -ot filename2 判断 filename1 的修改时间是否比 filename2 的旧。 filename1 -ef filename2 判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 数值比较 选 项 作 用 num1 -eq num2 相等 num1 -ne num2 不等 num1 -lt num2 &lt; num1 -gt num2 &gt; num1 -le num2 &lt;= num1 -ge num2 &gt;= 字符串判断 选 项 作 用 -z str 判断str 是否为空。 -n str 判断str 是否为非空。 str1 == str2 =和==是等价的，判断 str1 是否和 str2 相等。 str1 != str2 判断 str1 是否和 str2 不相等。 注意shell中==、&lt;, &gt; 只能用来比较字符串，不能比较数字... 整数运算(()) 待补充 for循环 待补充 函数 待补充 ","link":"https://achenq.github.io/post/shell-jiao-ben-bian-cheng/"},{"title":"利用precommit对git仓库进行检查","content":" 基本用法 yaml文件示例 python常用检查工具推荐 isort black mypy pre-commit可以很方便的管理git repo中的各种检查工具 其基本原理是作为git repo里面的钩子，可以对要提交的代码进行语法检查，格式化操作。 配置好之后，git commit时会自动触发检查 基本用法 安装pre-commit pip install pre-commit 进入项目根目录运行pre-commit install, 将pre-commit添加到此repo中的钩子中 在仓库的根目录下添加.pre-commit-config.yaml文件 运行pre-commit run --all-files即可开始检查 yaml文件示例 .pre-commit-config.yaml文件内容 --- default_stages: [commit] default_language_version: python: python3.8 repos: - repo: https://github.com/asottile/pyupgrade rev: v2.29.1 hooks: - id: pyupgrade args: [--py36-plus] 字段说明: default_stages: 在什么动作的时候触发pre-commit检查 repos: 使用什么工具进行检查 python常用检查工具推荐 pre-commit是通过添加对应的github repo地址添加检查工具的，所以需要对应的repo中有.pre-commit-hooks.yaml配置文件 isort 说明: 对import部分进行排序, 是的包导入更加规范，减少多人协作时由于修改包位置导致的冲突 主要分为以下四大类, 通类别内部按照字母顺序排序 from __future__ import absolute_import import os import sys from third_party import (lib1, lib2, lib3, lib4, lib5, lib6, lib7, lib8, lib9, lib10, lib11, lib12, lib13, lib14, lib15) from my_lib import Object, Object2, Object3 官方地址: isort black 介绍: 按照 PEP 8 规范自动格式化python代码 官方地址: black 注意isort和black一起用时会有冲突, 使用--profile=black参数来避免冲突 - repo: https://github.com/pycqa/isort rev: 5.5.2 hooks: - id: isort types: [python] args: [&quot;--profile=black&quot;] mypy 介绍: python静态语法检查 注意mypy没有官方适配pre-commit，所以可以使用pre-commit提供的镜像仓库 mypy静态仓库: mirrors-mypy 官方地址: mypy 配置参考 - repo: https://github.com/pre-commit/mirrors-mypy rev: v0.910 hooks: - id: mypy types: [python] exclude: &quot;(test_\\\\w*\\\\.py$)&quot; additional_dependencies: [types-PyYAML, types-mock, types-requests&gt;=2.26.0, click] args: [ &quot;--cache-dir=/tmp/mypy_cache/&quot;, &quot;--ignore-missing-imports&quot;, &quot;--warn-unreachable&quot;, &quot;--show-error-code&quot;, &quot;--strict-equality&quot;, &quot;--strict&quot;, ] ","link":"https://achenq.github.io/post/li-yong-precommit-dui-git-cang-ku-jin-xing-jian-cha/"},{"title":"ubuntu 装机","content":"今天整了一下Ubuntu，中间所有命令整理在下面以便下次使用 安装zsh &amp; ohmyzsh &amp; 导入配置 &amp; 安装ohmyzsh插件 apt update apt install zsh chsh -s /bin/zsh # 默认zsh sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; mkdir ~/zhen_code git clone https://github.com/AChenQ/config.git ~/zhen_code/config ln -s ~/zhen_code/config/shell/zhen-cloud.zsh-theme ~/.oh-my-zsh/custom/themes/zhen-cloud.zsh-theme ln -s ~/zhen_code/config/shell/.zshrc ~/.zshrc git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions apt install autojump 安装neovim &amp; 导入配置 add-apt-repository ppa:jonathonf/vim add-apt-repository ppa:neovim-ppa/unstable apt install vim apt install neovim apt install npm n stable npm install -g n npm install -g neovim mkdir ~/.config ln -s ~/zhen_code/config/nvim ~/.config/nvim sh -c 'curl -fLo &quot;${XDG_DATA_HOME:-$HOME/.local/share}&quot;/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 安装pyenv(python环境管理), tmux(linux Session窗口管理) curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | zsh apt install build-essential zlib1g-dev patch ruby gem ruby-dev libffi-dev tmux gem install neovim pyenv install 3.9.5 pyenv global 3.9.5 pip install neovim git全局配置 git config --global user.name &quot;zhenchen&quot; git config --global user.email &quot;cz2350276852@163.com&quot; git config --global core.editor &quot;nvim&quot; ","link":"https://achenq.github.io/post/ubuntu-zhuan-ji/"},{"title":"10min 搭建V2ray梯子","content":"主要参考下列教程进行搭建 美国VPS Hostwinds一键脚本搭建V2Ray最新中文教程 在搭建过程中对上列教程一些补充的点: 按照教程在服务器上安装好V2ray后，没有发现教程有提及如何下载 v2rayN.exe文件 可以在此链接下载 v2rayN-Core 下载后解压打开，继续流程即可 windows powershell 终端代理开启 $Env:http_proxy=&quot;http://127.0.0.1:10809&quot;;$Env:https_proxy=&quot;http://127.0.0.1:10809&quot; 点击设置可以看到V2ray是监听的10808端口, 然后默认情况下代理是socks+1，所以是10809 生成链接二维码和url v2ray url : 生成 vmess URL 链接 v2ray qr : 生成二维码链接 v2ray ssqr : 生成 Shadowsocks 二维码链接 4.PAC模式使用 PAC模式下，需要自定义需要代理网址的名单，不在名单中的则一律不走代理 按照下列模式添加即可 ip被封如何修复 使用一段时间突然发现不能访问服务器了，和客服交流后，知道可以修改ip地址，按照下列网址解决即可 参考: https://www.vps234.com/hostwinds-ip-blocked-fix-isp/ ","link":"https://achenq.github.io/post/da-jian-ti-zi/"},{"title":"ssh 免密登录","content":"本机登录服务器免密登录步骤 1.在本机上生成公钥 ssh-keygen -t rsa 2.将生成的公钥上传至服务器上 scp -p ~/.ssh/id_rsa.pub user@&lt;ip&gt;:~/.ssh/authorized_keys 3.登录服务器设置权限 chmod 600 .ssh/authorized_keys chmod 700 .ssh 4.修改ssh配置文件(linux) 为保护文件，需要root权限 vi /etc/ssh/sshd_config 保证下面三个配置均为yes RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 5.重启ssh服务 sudo service sshd restart 现在就可以免密登陆了 ","link":"https://achenq.github.io/post/ssh-mian-mi-deng-lu/"},{"title":"RESTfulAPI简介","content":" RESTful API主要特征 URL路径设计 HTTP动词 状态码和返回数据 RESTful目前在很多公司都有着广泛的应用, 其中Github的API设计就是很标准的RESTful API. 可以在这里中看到许多实际的api: github restful api, 这也是我之前项目中一个重要的参考学习点. RESTful API 就是满足REST架构风格的接口, 而REST是一种设计风格, 所以其并没有一个很严格的标准, 只是当作指导方向即可. RESTful API主要特征 以资源为基础: 除了二进制的资源外, 更多的信息普遍以json格式 统一接口: 对资源的操作包括获取、创建、修改和删除，分别对应HTTP协议提供的GET、POST、PUT和DELETE方法. 所以, 使用RESTful风格的接口可能只定位其资源, 而具体的操作则通过HTTP协议的不同方法来判断. GET（SELECT）：从服务器取出资源(一项或多项) POST（CREATE）：在服务器新建一个资源 PUT（UPDATE）：在服务器更新资源(客户端提供完整数据) PATCH（UPDATE）：在服务器更新资源(客户端提供修改的部分数据) DELETE（DELETE）：从服务器删除资源 URI指向资源: 每种资源可能由一个或多个URI对应，每个URI只指向一种资源 无状态: 服务器不保存客户端的信息, 每一次从客户端发送的请求中, 要包含所有必须的状态信息, 会话信息由客户端保存, 服务器端根据这些状态信息来处理请求 要从URL路径、HTTP请求动词、状态码和返回结果等方面详细考虑。至于其他的方面例如错误处理、过滤信息等规范这里就不详细介绍了。 URL路径设计 通常是通过URL定位到资源: 而一个完整的URL组成通常由以下几个部分构成： URI = scheme &quot;://&quot; host &quot;:&quot; port &quot;/&quot; path [ &quot;?&quot; query ][ &quot;#&quot; fragment ] scheme: 指底层用的协议，如http、https、ftp host: 服务器的IP地址或者域名 port: 端口，http默认为80端口 path: 访问资源的路径，就是各种web 框架中定义的route路由 query: 查询字符串，为发送给服务器的参数，在这里更多发送数据分页、排序等参数。 fragment: 锚点，定位到页面的资源 其中path是尤其需要认真考虑的, 通常一个RESTful API的path组成如下： /{version}/{resources}/{resource_id} 这是找到的一些规范，设计时可以参考 不用大写字母，所有单词使用英文且小写。 连字符用中杠&quot;-&quot;而不用下杠&quot;_&quot; 正确使用 &quot;/&quot;表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定 结尾不要包含正斜杠分隔符&quot;/&quot; URL中不出现动词，用请求方式表示动作 资源表示用复数不要用单数 不要使用文件扩展名 HTTP动词 不同操作具体的含义如下： GET /collection：从服务器查询资源的列表 GET /collection/resource：从服务器查询单个资源 POST /collection：在服务器创建新的资源 PUT /collection/resource：更新服务器资源 DELETE /collection/resource：从服务器删除资源 注意RESTful风格的API要求在URL上都以名词的方式出现，从几种请求方式上就可以看出想要进行的操作 状态码和返回数据 状态码主要分为五大类： 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 细分说明 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 ","link":"https://achenq.github.io/post/restfulapi-jian-jie/"},{"title":"selenium使用","content":"Select选择框使用 支持选择框选择，注意仅支持select元素，不支持div等元素 from selenium.webdriver.support.select import Select element = driver.find_element_by_xpath(&quot;//select&quot;) Select(element).select_by_value(&quot;value1&quot;) xpath语法： //div 根目录开始匹配div元素 //div[@id=&quot;as&quot;] 根目录开始匹配id为as的div元素 //div[@id=&quot;as&quot;]//* 根目录开始匹配id为as的div元素后所有的元素 //a[text()=&quot;as&quot;] 匹配text为as的a元素 //tbody//tr[1] tbody下的第一个tr元素，注意xpath列表从1开始...(违反直觉) &quot;//i[contains(@class, 'aaa')] class名字包括aaa的i元素 ","link":"https://achenq.github.io/post/xpath-shi-yong/"},{"title":"Windows下配置nvim","content":" 目录 安装 nvim 缺少插件问题 ctag ctrlsf markdown python找不到 coc-config 目录 安装 nvim 配置了ChocolateyGet, 之后，直接安装即可 choco install neovim nvim配置文件地址: nvim C:\\Users\\hjjge\\AppData\\Local\\nvim\\init.vim 运行checkhealth 缺少插件问题 ctag 使用 tagbarToggle报错 Tagbar: Exuberant ctags not found! Please downloa_NYcc 安装 ctag即可, 在网址ctags下载ctags.ext文件，然后放在在环境变量中的地址即可 ctrlsf Ctrlsf需要基于某个别的应用来搜索，推荐rg，直接安装即可 choco install ripgrep markdown 安装了tabline后，markdown文件会自动折叠，非常不利于修改 可以添加下列配置进行关闭 au FileType markdown let g:indentLine_setConceal= 0 参考: https://github.com/Yggdroot/indentLine/issues/349 python找不到 添加下列配置，设置python地址为python3 let g:syntastic_python_python_exec = 'python3' 并且安装pip install neovim coc-config 输入 CocConfig， 即可打开coc的配置文件 { &quot;coc.preferences.rootPatterns&quot;: [&quot;.git&quot;], &quot;python.linting.enabled&quot;: false, &quot;python.pythonPath&quot;: &quot;python&quot;, &quot;translator.engines&quot;: [ &quot;google&quot;, &quot;youdao&quot;, &quot;haici&quot; ], &quot;translator.maxsize&quot;: 1000, &quot;translator.window.maxWidth&quot;: 500, &quot;translator.window.maxHeight&quot;: 500, } ","link":"https://achenq.github.io/post/windows-xia-pei-zhi-nvim/"},{"title":"windows装机","content":"windows devcon 工具下载 https://superuser.com/questions/1002950/quick-method-to-install-devcon-exe devcon.exe可以支持重新扫描硬件驱动，卸载硬件驱动 用法: https://blog.csdn.net/zhangzxing/article/details/9231155 阿里云驱动安装: https://help.aliyun.com/document_detail/217543.html win7 强制开启开启测试模式，并添加驱动签名，绕过签名检查 https://www.ngohq.com/driver-signature-enforcement-overrider.html ","link":"https://achenq.github.io/post/windows-zhuanji/"},{"title":"git使用","content":" git使用集合 删除本地commit 查看git操作记录 重命名远程分支 git 取消之前的commit --amend git合并多个历史commit 远程分支查看 warring提示 warning: LF will be replaced by CRLF git使用集合 删除本地commit git reset --soft HEAD~1 git reset --hard HEAD~1 soft和hard的区别为，soft会将撤销的commit修改放在暂存区中，hard则不会保留 查看git操作记录 git reflog gridea的机制是不保留commit，会强制覆盖整个仓库， 我之前不了解这个机制，导致本地和云端的笔记都被强制覆盖成初始状态了 最终靠relog找到了最开始clone下来时的commit，才找回了之前的笔记 重命名远程分支 先本地将分支修改为目标名字, 推送目标分支到远端，再删除远端分支 示例，将dev修改为develop git checkout dev git pull origin dev git checkout master git branch -m dev devlope git push origin develop git push origin --delete develop git 取消之前的commit --amend 如果只amend了一次，则直接reset即可 git reset HEAD~1 如果amend了多次，则先使用relog查看需要撤销多少次操作，再使用reset撤销 git reflog git reset HEAD~2 默认是soft模式，即把修改返回到暂存区 也可以使用hard，直接丢弃修改代码 git reset --hard HEAD~1 git合并多个历史commit # 合并历史两个提交 git rebase -i HEAD~2 弹出以下修改界面，按照提示选择前面关键字为s或者d等即可 pick f0b7d8sdf 历史提交1 pick f7c223889 历史提交2 修改为, 即表示将历史提交2压缩至历史提交1中 pick f0b7d8sdf 历史提交1 s f7c223889 历史提交2 远程分支查看 官方详细文档git remote branchs 注意在本地仓库中，远程分支有git进行管理，不能直接修改，仅能查看 即如果你只想查看远程仓库中的某个分支的代码时，使用下面代码即可切换到对应的远程分支进行查看 git fetch # 将远程分支同步为最新 git checkout origin/branchName warring提示 warning: LF will be replaced by CRLF 问题是由于windows，linux，macos三种系统的文件换行符不一致 windows多数编辑器会使用lf的换行，所以为了支持跨平台的情况，git在提交的时候会自动将LF换行符替换为CRLF 配置下列命令来显示支持自动转换 git config --global core.autocrlf true ","link":"https://achenq.github.io/post/git-shi-yong/"},{"title":"Windows安装配置PowerShell","content":" 安装 windows Terminal 安装 windows power shell 安装 oh my posh 插件 Alias 软链接 包管理 clashx代理 以下操作均在win11下安装 #目录 安装 windows Terminal 直接在下列地址下载最新的exe，点击安装即可 microsoft-terminal 安装 windows power shell 首先查看当前的版本, 通常情况下自带的是5.x版本 $PSVersionTable 访问官网进行下载: powershell 下载最新的msi文件 安装 oh my posh 运行下列命令即可安装 winget install JanDeDobbeleer.OhMyPosh -s winget 在$profile添加下列行用以设置主题 直接 vim $profile即可打开配置文件 oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\amro.omp.json&quot; | Invoke-Expression 访问oh my posh 文档获取更详细的配置 插件 安装PSReadLine获取命令自动补全功能 Install-Module PSReadLine 并在$profile文件中添加下列行开启此功能 # auto suggestions Import-Module PSReadLine Set-PSReadLineOption -PredictionSource History 安装posh-git获取git信息显示功能 Install-Module posh-git Alias 在$profile中通过下列方式添加alias function gitStatus{ git status } Set-Alias gst gitStatus 注意如果配置的快捷命令已存在的话，需要先解除绑定 Remove-Item alias:\\ls 软链接 文件 New-Item -ItemType SymbolicLink -Path C:\\Users\\hjjge\\AppData\\Local\\nvim\\init.vim -Target init.vim 文件夹软链接 管理员运行cmd, 注意只有cmd才有mklink这个命令 在D盘下生成一个指向E盘文件夹example的软连接link文件夹 mklink /d D:\\link E:\\example 包管理 可以使用chocolatey进行安装， 先安装ChocolateyGet Install-PackageProvider ChocolateyGet -Force 如果要安装 nodejs , 直接这样安装即可 Find-Package nodejs -Verbose -Provider ChocolateyGet | Install-Package 官网: ChocolateyGet clashx代理 获取命令后，粘贴在命令行运行即可，类似 $Env:http_proxy=&quot;http://127.0.0.1:7890&quot;;$Env:https_proxy=&quot;http://127.0.0.1:7890&quot; ","link":"https://achenq.github.io/post/windows-an-zhuang-pei-zhi-powershell/"},{"title":"在vim中使用TabNine","content":"在vim中使用tabnine, tabnine是一个智能补全的工具 其原始项目地址: TabNine 下面将介绍两种方式来进行安装，我自己是通过coc来使用tabnine 使用Plugin管理 使用coc管理 使用Plugin 原项目地址: tabnine-vim 使用步骤: 添加 &quot;Plug 'zxqfl/tabnine-vim' 运行:PlugInstall即可 开启配置方式: 新建一个空白文件 输入TabNine::config即可开启配置页面 输入TabNine::sem即可打开当前语言的自动补全 但是这样对我来说有一个问题，我安装的其他coc插件会没法正常使用 比如coc-word将不会自动帮你补全英文单词 所以我采用的是coc进行管理 使用coc 原项目地址: coc-tabnine 使用步骤: 运行:CocInstall coc-tabnine安装tabnine插件 运行:CocCommand tabnine.updateTabNine进行升级 开启配置方式: 开启配置文件: CocCommand tabnine.openConfig 开启设置网址: CocCommand tabnine.openHub 备注: 新建一个txt文件，输入上面的命令，即可开启对应的配置页面 （因为理论上安装了coc-tabnine 之后，vim输入的所有文字都会被输入到tabnine中进行智能补全，所以新开一个文件，输入上面的命令tabnine就可以检测到了） 接下来接可以开始流畅的码代码啦，可以看到提示菜单中，后缀标签为[TN]即tabnine提供的提示 ","link":"https://achenq.github.io/post/zai-vim-zhong-shi-yong-tabnine/"},{"title":"批量解压shell脚本","content":"最近需要，写了一波批量解压脚本, 记录一下 #! /bin/sh for i in *.zip do k=$i s=${k%.zip*} echo $s ditto -V -x -k --sequesterRsrc $i $s rm $i done 步骤 将脚本记录在unzip.sh文件中 进入tmp目录，运行./unzip.sh 解压前zip包的结构 tmp ├── data.zip └── data1.zip 解压后结构 tmp ├── data └── data1 备注: 使用ditto命令进行解压，是因为在macos系统中，unzip不能处理&quot;资源分叉&quot;的文件，关于&quot;资源分叉&quot;，详见:https://en.wikipedia.org/wiki/Resource_fork 解压7z的脚本 #! /bin/sh for i in *.7z do k=$i s=${k%.7z*} echo $s 7z x $i -o$s rm $i done 解压目录所有子文件夹中的zip包 #! /bin/sh for j in ./* do for i in $j/*.zip do k=$i s=${k%.zip*} echo $s ditto -V -x -k --sequesterRsrc $i $s rm $i done done ","link":"https://achenq.github.io/post/pi-liang-jie-ya-shell-jiao-ben/"},{"title":"单元测试准则","content":" 不应该编写成功通过的单元测试-它们应该被写成不通过的。你可以在几分钟内让任何一组测试通过，但这只是在欺骗你自己。 测试类应该只测试一个功能-你应该用一个功能去测试一个方法。否则，你会违反了单一职责原则。 测试类具备可读性-确保测试类标有注释并且容易理解，就像其他的代码一样。 良好的命名规范-再次测试时应该像其他代码一样-便于人们理解。 把断言从行为中分离出来-你的断言应该用来检验结果，而不是执行逻辑操作的。 使用具体的输入-不要使用任何的自动化测试数据来输入，像date()这些产生的数据会引入差异。 把测试类分类，放在不同的地方-从逻辑的角度看，当没有错误指向特定的问题时这更容易去查找。 好的测试都是一些独立的测试类-你应该让测试类与其他的测试、环境设置等没有任何依赖。这利于创建多个测试点。 不要包含私有的方法-他们都是一些具体的实现，不应该包含在单元测试里。 不要连接数据库或者数据源-这是不靠谱的。因为你不能确保数据服务总是一样的并且能够创建测试点。 一个测试不要超过一个模拟(mock对象)-我们努力去消除错误和不一致性。 单元测试不是集成测试-如果你想测试结果，不要使用单元测试。 测试必须具有确定性-你需要一个确定的预测结果，所以，如果有时候测试通过了，但是不意味着完成测试了。 保持你的测试是幂等的-你应该能够运行你的测试多次而不改变它的输出结果，并且测试也不应该改变任何的数据或者添加任何东西。无论是运行一次还是一百万次，它的效果都应该是一样的。 测试类一次仅测试一个类，测试方法一次仅测试一个方法-组织方法能够在问题出现时检测出来，并帮你确定测试依赖。 在你的测试里使用异常-你在测试里会遇到异常，所以，请不要忽略它，要使用它。 不要使用你自己的测试类去测试第三方库的功能-大多数好的库都应该有它们自己的测试，如果没考虑用mocks去产生一致性的结果的话。 限制规则-当在一些规则下写测试时，记住你的限制和它们（最小和最大）设置成最大的一致性。 测试类不应该需要配置或者自定义安装-你的测试类应该能够给任何人使用并且使它运行。“在我的机器上运行”不应该出现在这。 ","link":"https://achenq.github.io/post/dan-yuan-ce-shi-zhun-ze/"},{"title":"zsh 配置","content":" 目录 oh my zsh 主题 自定义主题 调色板 插件 autosuggestions autojump 整了一下自己zsh的配置，在这里将其记录下来 目录 oh my zsh oh my zsh是一款基于zsh命令行的扩展工具集，我们可以通过它简单，快速的配置出自己喜欢的命令行风格 mac目前开始默认使用zsh作为shell(ubuntu也可以自行安装zsh) 你可以通过下列命令一键安装oh my zsh sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 具体详情参照官网: ohmyzsh ps: 安装之后，原来的默认~/.zshrc文件会被重命名为~/.zshrc.pre-oh-my-zsh, 新的.zshrc文件为oh my zsh的配置文件 主题 oh my zsh默认提供了很多不同风格的主题，只需要修改~/.zshrc文件中的ZSH_THEME=&quot;主题&quot;字段即可 我设置的为ZSH_THEM=cloud 官方提供的主题地址: themes 自定义主题 如果对提供的样例主题不满意，你也可以自定义配置主题 下图是我配置的终端界面，仅显示我想显示的信息 在上图界面显示中，前面的云朵图案可以按自己的喜好更改，随后依次显示登陆用户名，路径，git信息 右侧则显示的为我当前所使用pyenv工具中python环境的名称 自定义主题具体步骤 在~/.oh-my-zsh/themes/中新建一个文件，文件名即为主题名，使用上述的ZSH_THEME配置 ZSH_THEME_CLOUD_PREFIX='☁️' #后面的☁️图案实际上显示是上图中的云朵图案，只不过代码框中不支持 PROMPT='%{$fg_bold[cyan]%}$ZSH_THEME_CLOUD_PREFIX %{$fg[white]%}%n%{$fg_bold[green]%}%p %{$fg[green]%}%~ %{$fg_bold[cyan]%}$(git_prompt_info)%{$fg_bold[blue]%} %{$reset_color%}' RPROMPT='%{$fg[yellow]%}$(pyenv_prompt_info)' 配置方法为%{$fg[color]%}%message 如%{$fg[white]%}%n意思便是显示颜色为白色的用户名 ps: PROMPT是指命令行从左往右开始依次显示什么信息，RPROMPT则是从右往左 下表显示一些常用的信息表示符，详细配置请见官网: Prompt-Expansion 转义变量 描述 %* 系统时间（时：分：秒） %D 系统日期（年-月-日） %n 你的用户名 %~ 你目前的工作目录相对于～的相对路径（可能在某些zsh版本可能造成乱码） %M 计算机的主机名 也可以通过编写函数，达到更加复杂的显示逻辑，比如超过多少个字符就将其折叠 调色板 由于不同终端的调色板不一样，可能显示出的样式会和样例图有出入 分享一下我使用的调色板, 地址: https://draculatheme.com/iterm/ 各颜色示例 插件 oh my zsh还可以快速便捷安装非常好用的插件，这里推荐两个我最常用的，用过之后再也离不开了的那种 autosuggestions 这个插件会记录你之前输入过的历史命令，并且自动根据当前输入的前缀在历史命令中进行匹配，如果你想直接输入历史命令，按小键盘的→即可补全，类似这样： 安装命令: git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 原地址：zsh-autosuggesstions autojump 与传统的 cd 命令相比，autojump 能够更加快速地导航至目的目录 你可以直接通过 j + 文件夹名进行目录跳转，前提是历史曾经进入过的目录 同时auto夹提供很多其他的命令如jo打开文件夹等，详情见官网:https://github.com/wting/autojump mac安装 brew update brew install autojump ubuntu 安装 apt install autojump ","link":"https://achenq.github.io/post/zsh/"}]}